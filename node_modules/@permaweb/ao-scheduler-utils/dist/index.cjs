var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var src_exports = {};
__export(src_exports, {
  InvalidSchedulerLocationError: () => InvalidSchedulerLocationError,
  SchedulerTagNotFoundError: () => SchedulerTagNotFoundError,
  TransactionNotFoundError: () => TransactionNotFoundError,
  connect: () => connect,
  locate: () => locate,
  raw: () => raw,
  validate: () => validate
});
module.exports = __toCommonJS(src_exports);

// src/client/gateway.js
var import_ramda = require("ramda");

// src/err.js
var InvalidSchedulerLocationError = class _InvalidSchedulerLocationError extends Error {
  static name = "InvalidSchedulerLocation";
  constructor(...args) {
    super(...args);
    this.name = _InvalidSchedulerLocationError.name;
  }
};
var SchedulerTagNotFoundError = class _SchedulerTagNotFoundError extends Error {
  static name = "SchedulerTagNotFound";
  constructor(...args) {
    super(...args);
    this.name = _SchedulerTagNotFoundError.name;
  }
};
var TransactionNotFoundError = class _TransactionNotFoundError extends Error {
  static name = "TransactionNotFound";
  constructor(...args) {
    super(...args);
    this.name = _TransactionNotFoundError.name;
  }
};

// src/client/gateway.js
var URL_TAG = "Url";
var TTL_TAG = "Time-To-Live";
var SCHEDULER_TAG = "Scheduler";
var findTagValue = (name) => (0, import_ramda.pipe)(
  (0, import_ramda.defaultTo)([]),
  (0, import_ramda.find)((0, import_ramda.propEq)(name, "name")),
  (0, import_ramda.defaultTo)({}),
  (0, import_ramda.prop)("value")
);
var findTransactionTags = (err) => (0, import_ramda.pipe)(
  (transaction) => {
    if (!transaction)
      throw new TransactionNotFoundError(err);
    return transaction;
  },
  (0, import_ramda.prop)("tags"),
  (0, import_ramda.defaultTo)([])
);
function gatewayWith({ fetch: fetch2, GATEWAY_URL: GATEWAY_URL2 }) {
  return async ({ query, variables }) => {
    return fetch2(`${GATEWAY_URL2}/graphql`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query, variables })
    }).then((res) => res.json());
  };
}
function loadProcessSchedulerWith({ fetch: fetch2, GATEWAY_URL: GATEWAY_URL2 }) {
  const gateway = gatewayWith({ fetch: fetch2, GATEWAY_URL: GATEWAY_URL2 });
  const loadScheduler = loadSchedulerWith({ fetch: fetch2, GATEWAY_URL: GATEWAY_URL2 });
  const GET_TRANSACTIONS_QUERY = `
    query GetTransactions ($transactionIds: [ID!]!) {
      transactions(ids: $transactionIds) {
        edges {
          node {
            tags {
              name
              value
            }
          }
        }
      }
    }
  `;
  return async (process2) => {
    return gateway({ query: GET_TRANSACTIONS_QUERY, variables: { transactionIds: [process2] } }).then((0, import_ramda.path)(["data", "transactions", "edges", "0", "node"])).then(findTransactionTags(`Process ${process2} was not found on gateway ${GATEWAY_URL2}`)).then(findTagValue(SCHEDULER_TAG)).then((walletAddress) => {
      if (!walletAddress)
        throw new SchedulerTagNotFoundError('No "Scheduler" tag found on process');
      return loadScheduler(walletAddress);
    });
  };
}
function loadSchedulerWith({ fetch: fetch2, GATEWAY_URL: GATEWAY_URL2 }) {
  const gateway = gatewayWith({ fetch: fetch2, GATEWAY_URL: GATEWAY_URL2 });
  const GET_SCHEDULER_LOCATION = `
    query GetSchedulerLocation ($owner: String!) {
      transactions (
        owners: [$owner]
        tags: [
          { name: "Data-Protocol", values: ["ao"] },
          { name: "Type", values: ["Scheduler-Location"] }
        ]
        # Only need the most recent Scheduler-Location
        sort: HEIGHT_DESC
        first: 1
      ) {
        edges {
          node {
            tags {
              name
              value
            }
          }
        }
      }
    }
  `;
  return async (walletAddress) => gateway({ query: GET_SCHEDULER_LOCATION, variables: { owner: walletAddress } }).then((0, import_ramda.path)(["data", "transactions", "edges", "0", "node"])).then(findTransactionTags(`Could not find 'Scheduler-Location' owner by wallet ${walletAddress}`)).then((0, import_ramda.juxt)([
    findTagValue(URL_TAG),
    findTagValue(TTL_TAG)
  ])).then(([url, ttl]) => {
    if (!url)
      throw new InvalidSchedulerLocationError('No "Url" tag found on Scheduler-Location');
    if (!ttl)
      throw new InvalidSchedulerLocationError('No "Time-To-Live" tag found on Scheduler-Location');
    return { url, ttl, owner: walletAddress };
  });
}

// src/client/in-memory.js
var import_lru_cache = require("lru-cache");
var internalCache;
var internalSize;
function createLruCache({ size }) {
  if (internalCache)
    return internalCache;
  internalSize = size;
  internalCache = new import_lru_cache.LRUCache({
    /**
     * number of entries
     */
    max: size,
    /**
     * max size of cache, as a scalar.
     *
     * In our case, characters (see sizeCalculation)
     */
    maxSize: 1e6 * 5,
    /**
     * Simply stringify to get the bytes
     */
    sizeCalculation: (v) => JSON.stringify(v).length,
    allowStale: true
  });
  return internalCache;
}
function getByProcessWith({ cache = internalCache }) {
  return async (process2) => {
    if (!internalSize)
      return;
    return cache.get(process2);
  };
}
function setByProcessWith({ cache = internalCache }) {
  return async (process2, { url, address }, ttl) => {
    if (!internalSize)
      return;
    return cache.set(process2, { url, address }, { ttl });
  };
}
function getByOwnerWith({ cache = internalCache }) {
  return async (owner) => {
    if (!internalSize)
      return;
    return cache.get(owner);
  };
}
function setByOwnerWith({ cache = internalCache }) {
  return async (owner, url, ttl) => {
    if (!internalSize)
      return;
    return cache.set(owner, { url, address: owner }, { ttl });
  };
}

// src/client/scheduler.js
function checkForRedirectWith({ fetch: fetch2 }) {
  return async (url, process2) => {
    const response = await fetch2(`${url}?process-id=${process2}`, { method: "GET", redirect: "manual" });
    if ([301, 302, 307, 308].includes(response.status)) {
      return new URL(response.headers.get("Location")).origin;
    }
    return url;
  };
}

// src/locate.js
function locateWith({ loadProcessScheduler, cache, followRedirects, checkForRedirect }) {
  const cacheResults = async (process2, scheduler, url) => {
    const res = { url, address: scheduler.owner };
    await Promise.all([
      cache.setByProcess(process2, res, scheduler.ttl),
      cache.setByOwner(scheduler.owner, url, scheduler.ttl)
    ]);
    return res;
  };
  return (process2) => cache.getByProcess(process2).then((cached) => {
    if (cached)
      return cached;
    return loadProcessScheduler(process2).then(async (scheduler) => {
      let finalUrl = scheduler.url;
      if (followRedirects) {
        finalUrl = await checkForRedirect(scheduler.url, process2);
      }
      return cacheResults(process2, scheduler, finalUrl);
    });
  });
}

// src/raw.js
function rawWith({ loadScheduler, cache }) {
  return (address) => cache.getByOwner(address).then((cached) => {
    if (cached)
      return { url: cached.url };
    return loadScheduler(address).then(
      (scheduler) => cache.setByOwner(address, scheduler.url, scheduler.ttl).then(() => ({ url: scheduler.url }))
    ).catch((err) => {
      if (err instanceof InvalidSchedulerLocationError)
        return void 0;
      throw err;
    });
  });
}

// src/validate.js
function validateWith({ loadScheduler, cache }) {
  return (address) => cache.getByOwner(address).then((cached) => {
    if (cached)
      return true;
    return loadScheduler(address).then((scheduler) => cache.setByOwner(address, scheduler.url, scheduler.ttl)).then(() => true).catch((err) => {
      if (err instanceof InvalidSchedulerLocationError)
        return false;
      throw err;
    });
  });
}

// src/index.common.js
var DEFAULT_GATEWAY_URL = "https://arweave.net";
function connect({ cacheSize = 100, GATEWAY_URL: GATEWAY_URL2 = DEFAULT_GATEWAY_URL, followRedirects = false } = {}) {
  const cache = createLruCache({ size: cacheSize });
  const getByOwner = getByOwnerWith({ cache });
  const getByProcess = getByProcessWith({ cache });
  const setByOwner = setByOwnerWith({ cache });
  const setByProcess = setByProcessWith({ cache });
  const locate2 = locateWith({
    loadProcessScheduler: loadProcessSchedulerWith({ fetch, GATEWAY_URL: GATEWAY_URL2 }),
    cache: { getByProcess, getByOwner, setByProcess, setByOwner },
    followRedirects,
    checkForRedirect: checkForRedirectWith({ fetch })
  });
  const validate2 = validateWith({
    loadScheduler: loadSchedulerWith({ fetch, GATEWAY_URL: GATEWAY_URL2 }),
    cache: { getByProcess, getByOwner, setByProcess, setByOwner }
  });
  const raw2 = rawWith({
    loadScheduler: loadSchedulerWith({ fetch, GATEWAY_URL: GATEWAY_URL2 }),
    cache: { getByProcess, getByOwner, setByProcess, setByOwner }
  });
  return { locate: locate2, validate: validate2, raw: raw2 };
}

// src/index.js
var GATEWAY_URL = process.env.GATEWAY_URL || void 0;
var CACHE_SIZE = process.env.SCHEDULER_UTILS_CACHE_SIZE || void 0;
var FOLLOW_REDIRECTS = process.env.SCHEDULER_UTILS_FOLLOW_REDIRECTS === "true" || void 0;
var { locate, validate, raw } = connect({ GATEWAY_URL, cacheSize: CACHE_SIZE, followRedirects: FOLLOW_REDIRECTS });
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  InvalidSchedulerLocationError,
  SchedulerTagNotFoundError,
  TransactionNotFoundError,
  connect,
  locate,
  raw,
  validate
});
